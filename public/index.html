<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>VoxTalk – Diagnostic Baseline</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="data:,">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="app">
    <h1>VoxTalk – Diagnostic Baseline</h1>

    <div class="controls">
      <button id="btnTestSession">Test /session</button>
      <button id="btnStartRealtime">Start Realtime</button>
      <button id="btnToggleHalo">Toggle Halo (Manual)</button>
    </div>

    <div class="status" id="status"></div>

    <button id="pttBtn" aria-pressed="false" title="Push to Talk"></button>
    <div class="hint">Click to talk (after “Start Realtime”)</div>
    <audio id="remote" autoplay playsinline></audio>
  </div>

  <button id="printBtn">🖨️ Print Conversation</button>

  <script>
    // --- helpers
    const statusEl = document.getElementById('status');
    function log(line, level = "info") {
      const el = document.createElement("div");
      el.className = level;
      el.textContent = line;
      statusEl.appendChild(el);
      statusEl.scrollTop = statusEl.scrollHeight;
      console[level === "err" ? "error" : "log"](line);
    }

    // capture all JS errors visibly
    window.addEventListener('error', (e) => log("[JS Error] " + e.message, "err"));
    window.addEventListener('unhandledrejection', (e) => log("[Promise Rejection] " + (e.reason?.message || e.reason), "err"));

    const pttBtn  = document.getElementById("pttBtn");
    const rtAudio = document.getElementById("remote");
    const btnTest = document.getElementById("btnTestSession");
    const btnRT   = document.getElementById("btnStartRealtime");
    const btnHalo = document.getElementById("btnToggleHalo");
    const printBtn= document.getElementById("printBtn");

    function setSpeaking(on) {
      pttBtn.classList.toggle("speaking", on);
      log(`[Halo] ${on ? "ON" : "OFF"}`, on ? "ok" : "info");
    }

    // manual halo test
    btnHalo.onclick = () => {
      const on = !pttBtn.classList.contains("speaking");
      setSpeaking(on);
    };

    // audio lifecycle visibility
    rtAudio.onplaying = () => { log("[Audio] playing", "ok"); setSpeaking(true); };
    const stopHalo = () => { log("[Audio] stopped", "info"); setSpeaking(false); };
    rtAudio.onended = stopHalo; rtAudio.onpause = stopHalo; rtAudio.onemptied = stopHalo;

    // print (kept simple)
    printBtn.onclick = () => window.print();

    let pc = null;
    let micTrack = null;
    let sessionCache = null;

    // ---- Test /session
    btnTest.onclick = async () => {
      try {
        log("POST /session …");
        const res = await fetch("/session", { method: "POST" });
        log(`[/session] status ${res.status}`, res.ok ? "ok" : "err");
        const data = await res.json().catch(()=> ({}));
        sessionCache = data;
        log(`[/session] keys: ${Object.keys(data).join(", ") || "(none)"}`, "info");
      } catch (err) {
        log("[/session] failed: " + err.message, "err");
      }
    };

    // ---- Start Realtime
    btnRT.onclick = async () => {
      try {
        log("Starting Realtime…");
        // fetch session if not done
        if (!sessionCache) {
          const res = await fetch("/session", { method: "POST" });
          log(`[/session] status ${res.status}`, res.ok ? "ok" : "err");
          sessionCache = await res.json();
        }
        const { client_secret, model, voice } = sessionCache || {};
        if (!client_secret?.value) { log("No client_secret.value in /session response", "err"); return; }

        // reset previous
        if (pc) { pc.close(); pc = null; rtAudio.srcObject = null; }

        pc = new RTCPeerConnection();
        const mic = await navigator.mediaDevices.getUserMedia({ audio: true });
        micTrack = mic.getTracks()[0];
        micTrack.enabled = false;
        pc.addTrack(micTrack, mic);
        log("[RTC] mic stream added", "ok");

        pc.ontrack = (ev) => {
          log("[RTC] ontrack (AI audio stream attached)", "ok");
          rtAudio.srcObject = ev.streams[0];
          rtAudio.play().catch(()=>{});
        };

        // **IMPORTANT**: listen to the incoming data channel (if OpenAI creates it)
        pc.ondatachannel = (e) => {
          log(`[RTC] ondatachannel: ${e.channel.label || "(no label)"}`, "ok");
          const dc = e.channel;
          dc.onmessage = (msg) => {
            let evt;
            try { evt = JSON.parse(msg.data); } catch { return; }
            if (evt.type === "response.audio.started") { log("[Event] response.audio.started", "ok"); setSpeaking(true); }
            if (evt.type === "response.audio.done" || evt.type === "output_audio_buffer.stopped") { log("[Event] response.audio.done", "info"); /* wait for audio end */ }
          };
        };

        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);
        log("[RTC] local SDP set", "ok");

        const r = await fetch(
          `https://api.openai.com/v1/realtime?model=${encodeURIComponent(model)}&voice=${voice}`,
          {
            method: "POST",
            headers: {
              "Authorization": `Bearer ${client_secret.value}`,
              "Content-Type": "application/sdp"
            },
            body: offer.sdp
          }
        );
        log(`[OpenAI /realtime] status ${r.status}`, r.ok ? "ok" : "err");
        const answerSDP = await r.text();
        await pc.setRemoteDescription({ type: "answer", sdp: answerSDP });
        log("[RTC] remote SDP set", "ok");

        // PTT behavior AFTER realtime starts
        pttBtn.onclick = () => {
          const next = !(micTrack && micTrack.enabled);
          if (micTrack) micTrack.enabled = next;
          pttBtn.setAttribute("aria-pressed", String(next));
          log(`[Mic] ${next ? "ON" : "OFF"}`, next ? "ok" : "info");
        };

      } catch (err) {
        log("[Start Realtime] failed: " + err.message, "err");
      }
    };

    // initial breadcrumb
    log("Page loaded. Use Test /session → Start Realtime.", "info");
  </script>
</body>
</html>
